<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/PodcastProject/src/main/java/podcast/model/services/PodcastService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/PodcastProject/src/main/java/podcast/model/services/PodcastService.java" />
              <option name="originalContent" value="package podcast.model.services;&#10;&#10;import jakarta.validation.Valid;&#10;import org.springframework.security.core.userdetails.UserDetails;&#10;import podcast.model.entities.dto.PodcastUpdateDTO;&#10;import podcast.model.entities.enums.Role;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.stereotype.Service;&#10;import podcast.model.entities.Podcast;&#10;import podcast.model.entities.User;&#10;import podcast.model.entities.dto.PodcastDTO;&#10;import podcast.model.entities.enums.Category;&#10;import podcast.model.exceptions.*;&#10;import podcast.model.repositories.interfaces.IPodcastRepository;&#10;import podcast.model.repositories.interfaces.IUserRepository;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;@Service&#10;public class PodcastService {&#10;&#10;    private final IPodcastRepository podcastRepository;&#10;    private final IUserRepository userRepository;&#10;&#10;    @Autowired&#10;    public PodcastService(IPodcastRepository podcastRepository, IUserRepository userRepository) {&#10;        this.podcastRepository = podcastRepository;&#10;        this.userRepository = userRepository;&#10;    }&#10;&#10;    public void save(Podcast podcast) {&#10;        podcastRepository.findAll().stream()&#10;                .filter(podcastpvt -&gt; podcastpvt.getTitle().equals(podcast.getTitle()))&#10;                .findFirst()&#10;                .ifPresent(podcastpvt -&gt; {&#10;                    throw new AlreadyCreatedException(&quot;Podcast with name &quot; + podcast.getTitle() + &quot; already exists&quot;);&#10;                });&#10;        if (podcast.getUser() == null || podcast.getUser().getId() == null) {&#10;            throw new NullUserException(&quot;Podcast must have a valid user&quot;);&#10;        }&#10;        User user = userRepository.findByIdWithCredentialAndRoles(podcast.getUser().getId())&#10;                .orElseThrow(() -&gt; new PodcastNotFoundException(&quot;User with ID &quot; + podcast.getUser().getId() + &quot; not found&quot;));&#10;&#10;        if (user.getCredential().getRoles() == null) {&#10;            user.getCredential().setRoles(new java.util.HashSet&lt;&gt;());&#10;        }&#10;&#10;        user.getCredential().getRoles().add(Role.ROLE_CREATOR);&#10;        userRepository.save(user);&#10;        podcastRepository.save(podcast);&#10;    }&#10;&#10;    public List&lt;PodcastDTO&gt; getAllFiltered(String title, Integer userId, Category category, Boolean orderByViews) {&#10;        List&lt;Podcast&gt; filtered;&#10;&#10;        if (title == null &amp;&amp; userId == null &amp;&amp; category == null) {&#10;            filtered = podcastRepository.findAll();&#10;        } else {&#10;&#10;            filtered = podcastRepository.findByUser_IdOrTitleIgnoreCaseOrCategories(userId, title, category);&#10;            if (filtered.isEmpty()) {&#10;                filtered = podcastRepository.findAll();&#10;            }&#10;        }&#10;&#10;        // Filtrar podcasts inactivos&#10;        List&lt;Podcast&gt; activeFiltered = filtered.stream()&#10;                .filter(p -&gt; Boolean.TRUE.equals(p.getIsActive()))&#10;                .toList();&#10;&#10;        if (activeFiltered.isEmpty()) {&#10;            throw new PodcastNotFoundException(&quot;No podcasts found&quot;);&#10;        }&#10;        List&lt;PodcastDTO&gt; filteredDTO = new ArrayList&lt;&gt;(activeFiltered.stream()&#10;                .map(Podcast::toDTO)&#10;                .toList());&#10;        if (orderByViews != null &amp;&amp; orderByViews) {&#10;            filteredDTO.sort((p1, p2) -&gt; Long.compare(p2.getAverageViews(), p1.getAverageViews()));&#10;        }&#10;        return filteredDTO;&#10;    }&#10;&#10;    public Podcast getPodcastById(Long podcastId) {&#10;        Podcast podcast = podcastRepository.findById(podcastId).orElseThrow( () -&gt;&#10;                new PodcastNotFoundException(&quot;Podcast with ID &quot; + podcastId + &quot; not found&quot;));&#10;        // No devolver podcasts inactivos&#10;        if (!Boolean.TRUE.equals(podcast.getIsActive())) {&#10;            throw new PodcastNotFoundException(&quot;Podcast with ID &quot; + podcastId + &quot; not found&quot;);&#10;        }&#10;        return podcast;&#10;    }&#10;&#10;    public List&lt;Podcast&gt; getByUsername(String username) {&#10;        List&lt;Podcast&gt; podcasts = podcastRepository.findByUser_Credential_Username(username);&#10;        // Filtrar inactivos&#10;        List&lt;Podcast&gt; active = podcasts.stream()&#10;                .filter(p -&gt; Boolean.TRUE.equals(p.getIsActive()))&#10;                .toList();&#10;        if (active.isEmpty()) {&#10;            throw new PodcastNotFoundException(&quot;No podcasts found for user &quot; + username);&#10;        }&#10;        return active;&#10;    }&#10;&#10;&#10;    public void deleteById(Long podcastId, String username) {&#10;        Podcast podcast = podcastRepository.findById(podcastId)&#10;                .orElseThrow(() -&gt; new PodcastNotFoundException(&quot;Podcast with ID &quot; + podcastId + &quot; not found&quot;));&#10;        if (!podcastRepository.existsById(podcastId)) {&#10;            throw new PodcastNotFoundException(&quot;Podcast with ID &quot; + podcastId + &quot; not found&quot;);&#10;        }&#10;        User user = userRepository.findByCredentialUsername(username).orElseThrow( () -&gt;&#10;                new UserNotFoundException(&quot;User with username &quot; + username + &quot; not found&quot;));&#10;&#10;        if (!podcast.getUser().getCredential().getUsername().equals(username) &amp;&amp; !user.getCredential().getRoles().contains(Role.ROLE_ADMIN)) {&#10;            throw new UnauthorizedException(&quot;Podcast with ID &quot; + podcastId + &quot; does not belong to YOU&quot; + username + &quot;and you are not an admin&quot;);&#10;        }&#10;        podcast.setIsActive(false);&#10;        podcastRepository.save(podcast);&#10;    }&#10;&#10;    public PodcastUpdateDTO updatePodcast(Long podcastId, @Valid PodcastUpdateDTO updates, UserDetails userDetails) {&#10;        Podcast podcast = podcastRepository.findById(podcastId)&#10;                .orElseThrow(() -&gt; new PodcastNotFoundException(&quot;Podcast with ID &quot; + podcastId + &quot; not found&quot;));&#10;&#10;        // Verifica que el usuario que intenta actualizar el podcast sea el propietario o un administrador&#10;        if (!podcast.getUser().getCredential().getUsername().equals(userDetails.getUsername()) &amp;&amp; !userDetails.getAuthorities().contains(Role.ROLE_ADMIN)) {&#10;            throw new UnauthorizedException(&quot;Podcast with ID &quot; + podcastId + &quot; does not belong to YOU &quot; + userDetails.getUsername());&#10;        }&#10;&#10;        // Actualiza los campos del podcast solo si están presentes en el DTO&#10;        if (updates.getTitle() != null &amp;&amp; !updates.getTitle().isBlank()) {&#10;            podcast.setTitle(updates.getTitle());&#10;        }&#10;        if (updates.getDescription() != null &amp;&amp; !updates.getDescription().isBlank()) {&#10;            podcast.setDescription(updates.getDescription());&#10;        }&#10;        if (updates.getImageUrl() != null &amp;&amp; !updates.getImageUrl().isBlank()) {&#10;            podcast.setImageUrl(updates.getImageUrl());&#10;        }&#10;        if (updates.getCategories() != null &amp;&amp; !updates.getCategories().isEmpty()) {&#10;            podcast.getCategories().addAll(updates.getCategories());&#10;        }&#10;        podcastRepository.save(podcast);&#10;        return podcast.toUpdateDTO();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package podcast.model.services;&#10;&#10;import jakarta.validation.Valid;&#10;import org.springframework.security.core.userdetails.UserDetails;&#10;import podcast.model.entities.dto.PodcastUpdateDTO;&#10;import podcast.model.entities.enums.Role;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.stereotype.Service;&#10;import podcast.model.entities.Podcast;&#10;import podcast.model.entities.User;&#10;import podcast.model.entities.dto.PodcastDTO;&#10;import podcast.model.entities.enums.Category;&#10;import podcast.model.exceptions.*;&#10;import podcast.model.repositories.interfaces.IPodcastRepository;&#10;import podcast.model.repositories.interfaces.IUserRepository;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;@Service&#10;public class PodcastService {&#10;&#10;    private final IPodcastRepository podcastRepository;&#10;    private final IUserRepository userRepository;&#10;&#10;    @Autowired&#10;    public PodcastService(IPodcastRepository podcastRepository, IUserRepository userRepository) {&#10;        this.podcastRepository = podcastRepository;&#10;        this.userRepository = userRepository;&#10;    }&#10;&#10;    public void save(Podcast podcast) {&#10;        podcastRepository.findAll().stream()&#10;                .filter(podcastpvt -&gt; podcastpvt.getTitle().equals(podcast.getTitle()))&#10;                .findFirst()&#10;                .ifPresent(podcastpvt -&gt; {&#10;                    throw new AlreadyCreatedException(&quot;Podcast with name &quot; + podcast.getTitle() + &quot; already exists&quot;);&#10;                });&#10;        if (podcast.getUser() == null || podcast.getUser().getId() == null) {&#10;            throw new NullUserException(&quot;Podcast must have a valid user&quot;);&#10;        }&#10;        User user = userRepository.findByIdWithCredentialAndRoles(podcast.getUser().getId())&#10;                .orElseThrow(() -&gt; new PodcastNotFoundException(&quot;User with ID &quot; + podcast.getUser().getId() + &quot; not found&quot;));&#10;&#10;        if (user.getCredential().getRoles() == null) {&#10;            user.getCredential().setRoles(new java.util.HashSet&lt;&gt;());&#10;        }&#10;&#10;        user.getCredential().getRoles().add(Role.ROLE_CREATOR);&#10;        userRepository.save(user);&#10;        podcastRepository.save(podcast);&#10;    }&#10;&#10;    public List&lt;PodcastDTO&gt; getAllFiltered(String title, Integer userId, Category category, Boolean orderByViews) {&#10;        List&lt;Podcast&gt; filtered;&#10;&#10;        if (title == null &amp;&amp; userId == null &amp;&amp; category == null) {&#10;            filtered = podcastRepository.findAll();&#10;        } else {&#10;&#10;            filtered = podcastRepository.findByUser_IdOrTitleIgnoreCaseOrCategories(userId, title, category);&#10;            if (filtered.isEmpty()) {&#10;                filtered = podcastRepository.findAll();&#10;            }&#10;        }&#10;&#10;        // Filtrar podcasts inactivos&#10;        List&lt;Podcast&gt; activeFiltered = filtered.stream()&#10;                .filter(p -&gt; Boolean.TRUE.equals(p.getIsActive()))&#10;                .toList();&#10;&#10;        if (activeFiltered.isEmpty()) {&#10;            throw new PodcastNotFoundException(&quot;No podcasts found&quot;);&#10;        }&#10;        List&lt;PodcastDTO&gt; filteredDTO = new ArrayList&lt;&gt;(activeFiltered.stream()&#10;                .map(Podcast::toDTO)&#10;                .toList());&#10;        if (orderByViews != null &amp;&amp; orderByViews) {&#10;            filteredDTO.sort((p1, p2) -&gt; Long.compare(p2.getAverageViews(), p1.getAverageViews()));&#10;        }&#10;        return filteredDTO;&#10;    }&#10;&#10;    public Podcast getPodcastById(Long podcastId) {&#10;        Podcast podcast = podcastRepository.findById(podcastId).orElseThrow( () -&gt;&#10;                new PodcastNotFoundException(&quot;Podcast with ID &quot; + podcastId + &quot; not found&quot;));&#10;        // No devolver podcasts inactivos&#10;        if (!Boolean.TRUE.equals(podcast.getIsActive())) {&#10;            throw new PodcastNotFoundException(&quot;Podcast with ID &quot; + podcastId + &quot; not found&quot;);&#10;        }&#10;        return podcast;&#10;    }&#10;&#10;    public List&lt;Podcast&gt; getByUsername(String username) {&#10;        List&lt;Podcast&gt; podcasts = podcastRepository.findByUser_Credential_Username(username);&#10;        // Filtrar inactivos&#10;        List&lt;Podcast&gt; active = podcasts.stream()&#10;                .filter(p -&gt; Boolean.TRUE.equals(p.getIsActive()))&#10;                .toList();&#10;        if (active.isEmpty()) {&#10;            throw new PodcastNotFoundException(&quot;No podcasts found for user &quot; + username);&#10;        }&#10;        return active;&#10;    }&#10;&#10;&#10;    public void deleteById(Long podcastId, String username) {&#10;        Podcast podcast = podcastRepository.findById(podcastId)&#10;                .orElseThrow(() -&gt; new PodcastNotFoundException(&quot;Podcast with ID &quot; + podcastId + &quot; not found&quot;));&#10;        if (!podcastRepository.existsById(podcastId)) {&#10;            throw new PodcastNotFoundException(&quot;Podcast with ID &quot; + podcastId + &quot; not found&quot;);&#10;        }&#10;        User user = userRepository.findByCredentialUsername(username).orElseThrow( () -&gt;&#10;                new UserNotFoundException(&quot;User with username &quot; + username + &quot; not found&quot;));&#10;&#10;        if (!podcast.getUser().getCredential().getUsername().equals(username) &amp;&amp; !user.getCredential().getRoles().contains(Role.ROLE_ADMIN)) {&#10;            throw new UnauthorizedException(&quot;Podcast with ID &quot; + podcastId + &quot; does not belong to YOU&quot; + username + &quot;and you are not an admin&quot;);&#10;        }&#10;        podcast.setIsActive(false);&#10;        podcastRepository.save(podcast);&#10;    }&#10;&#10;    public PodcastUpdateDTO updatePodcast(Long podcastId, @Valid PodcastUpdateDTO updates, UserDetails userDetails) {&#10;        Podcast podcast = podcastRepository.findById(podcastId)&#10;                .orElseThrow(() -&gt; new PodcastNotFoundException(&quot;Podcast with ID &quot; + podcastId + &quot; not found&quot;));&#10;&#10;        // Verifica que el usuario que intenta actualizar el podcast sea el propietario o un administrador&#10;        if (!podcast.getUser().getCredential().getUsername().equals(userDetails.getUsername()) &amp;&amp; !userDetails.getAuthorities().contains(Role.ROLE_ADMIN)) {&#10;            throw new UnauthorizedException(&quot;Podcast with ID &quot; + podcastId + &quot; does not belong to YOU &quot; + userDetails.getUsername());&#10;        }&#10;&#10;        // Actualiza los campos del podcast solo si están presentes en el DTO&#10;        if (updates.getTitle() != null &amp;&amp; !updates.getTitle().isBlank()) {&#10;            podcast.setTitle(updates.getTitle());&#10;        }&#10;        if (updates.getDescription() != null &amp;&amp; !updates.getDescription().isBlank()) {&#10;            podcast.setDescription(updates.getDescription());&#10;        }&#10;        if (updates.getImageUrl() != null &amp;&amp; !updates.getImageUrl().isBlank()) {&#10;            podcast.setImageUrl(updates.getImageUrl());&#10;        }&#10;        if (updates.getCategories() != null &amp;&amp; !updates.getCategories().isEmpty()) {&#10;            podcast.getCategories().addAll(updates.getCategories());&#10;        }&#10;        podcastRepository.save(podcast);&#10;        return podcast.toUpdateDTO();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>